
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Chapter 5: Reducing Side Effects Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch6.html" />
    
    
    <link rel="prev" href="ch4.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Foreword (TBA)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="preface.html">
            
                <a href="preface.html">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch1.html">
            
                <a href="ch1.html">
            
                    
                    Chapter 1: Why Functional Programming?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch2.html">
            
                <a href="ch2.html">
            
                    
                    Chapter 2: Foundations of Functional Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch3.html">
            
                <a href="ch3.html">
            
                    
                    Chapter 3: Managing Function Inputs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch4.html">
            
                <a href="ch4.html">
            
                    
                    Chapter 4: Composing Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.8" data-path="ch5.html">
            
                <a href="ch5.html">
            
                    
                    Chapter 5: Reducing Side Effects
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch6.html">
            
                <a href="ch6.html">
            
                    
                    Chapter 6: Value Immutability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch7.html">
            
                <a href="ch7.html">
            
                    
                    Chapter 7: Closure vs Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="ch8.html">
            
                <a href="ch8.html">
            
                    
                    Chapter 8: List Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="ch9.html">
            
                <a href="ch9.html">
            
                    
                    Chapter 9: Recursion
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="ch10.html">
            
                <a href="ch10.html">
            
                    
                    Chapter 10: Functional Async
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="ch11.html">
            
                <a href="ch11.html">
            
                    
                    Chapter 11: Putting It All together
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="apA.html">
            
                <a href="apA.html">
            
                    
                    Appendix A: Transducing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="apB.html">
            
                <a href="apB.html">
            
                    
                    Appendix B: The Humble Monad
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="apC.html">
            
                <a href="apC.html">
            
                    
                    Appendix C: FP Libraries
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Chapter 5: Reducing Side Effects</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="functional-light-javascript">Functional-Light JavaScript</h1>
<h1 id="chapter-5-reducing-side-effects">Chapter 5: Reducing Side Effects</h1>
<p>In Chapter 2, we discussed how a function can have outputs besides its <code>return</code> value. By now you should be very comfortable with the FP definition of a function, so the idea of such side outputs -- side effects! -- should smell.</p>
<p>We&apos;re going to examine the various different forms of side effects and see why they are harmful to our code&apos;s quality and readability.</p>
<p>But let me not bury the lede here. The punchline to this chapter: it&apos;s impossible to write a program with no side effects. Well, not impossible; you certainly can. But that program won&apos;t do anything useful or observable. If you wrote a program with zero side effects, you wouldn&apos;t be able to tell the difference between it and a deleted or empty program.</p>
<p>The FPer doesn&apos;t eliminate all side effects. Rather, the goal is to limit them as much as possible. To do that, we first need to fully understand them.</p>
<h2 id="effects-on-the-side-please">Effects On The Side, Please</h2>
<p>Cause and effect: one of the most fundamental, intuitive observations we humans can make about the world around us. Push a book off the edge of a table, it falls to the ground. You don&apos;t need a physics degree to know the cause was you pushing the book and the effect was gravity pulling it to the ground. There&apos;s a clear and direct relationship.</p>
<p>In programming, we also deal entirely in cause and effect. If you call a function (cause), it displays a message on the screen (effect).</p>
<p>When reading a program, it&apos;s supremely important that the reader be able to clearly identify each cause and each effect. To any extent where a direct relationship between cause and effect cannot be seen readily upon a read-through of the program, that program&apos;s readability is degraded.</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">var</span> y = foo( <span class="hljs-number">3</span> );
</code></pre>
<p>In this trivial program, it is immediately clear that calling foo (the cause) with value <code>3</code> will have the effect of returning the value <code>6</code> that is then assigned to <code>y</code> (the effect). There&apos;s no ambiguity here.</p>
<p>But now:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
    y = x * <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">var</span> y;

foo( <span class="hljs-number">3</span> );
</code></pre>
<p>This program has the exact same outcome. But there&apos;s a very big difference. The cause and the effect are disjoint. The effect is indirect. The setting of <code>y</code> in this way is what we call a side effect.</p>
<p><strong>Note:</strong> When a function makes a reference to a variable outside itself, this is called a free variable. Not all free variable references will be bad, but we&apos;ll want to be very careful with them.</p>
<p>What if I gave you a reference to call a function <code>bar(..)</code> that you cannot see the code for, but I told you that it had no such indirect side effects, only an explicit <code>return</code> value effect?</p>
<pre><code class="lang-js">bar( <span class="hljs-number">4</span> );            <span class="hljs-comment">// 42</span>
</code></pre>
<p>Because you know that the internals of <code>bar(..)</code> do not create any side effects, you can now reason about any <code>bar(..)</code> call like this one in a much more straightforward way. But if you didn&apos;t know that <code>bar(..)</code> had no side effects, to understand the outcome of calling it, you&apos;d have to go read and dissect all of its logic. This is extra mental tax burden for the reader.</p>
<p><strong>The readability of a side effecting function is less</strong> because it requires more reading to understand the program.</p>
<p>But the problem goes deeper than that. Consider:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

foo();

<span class="hljs-built_in">console</span>.log( x );

bar();

<span class="hljs-built_in">console</span>.log( x );

baz();

<span class="hljs-built_in">console</span>.log( x );
</code></pre>
<p>How sure are you what values are going to be printed at each <code>console.log(x)</code>?</p>
<p>The correct answer is: not at all. If you&apos;re not sure whether <code>foo()</code>, <code>bar()</code>, and <code>baz()</code> are side-effecting or not, you cannot guarantee what <code>x</code> will be at each step unless you inspect the implementations of each, <strong>and</strong> then trace the program from line one forward, keeping track of all the changes in state as you go.</p>
<p>In other words, the final <code>console.log(x)</code> is impossible to analyze or predict unless you&apos;ve mentally executed the whole program up to that point.</p>
<p>Guess who&apos;s good at running your program? The JS engine. Guess who&apos;s not as good at running your program? The reader of your code. And yet, your choice to write code with (potentially) side effects in one or more of those function calls means that you&apos;ve burdened the reader with having to mentally execute your program in its entirety up to a certain line, for them to understand to understand that line.</p>
<p>If <code>foo()</code>, <code>bar()</code>, and <code>baz()</code> were all free of side effects, they could not affect <code>x</code>, which means we do not need to execute them to mentally trace what happens with <code>x</code>. This is less mental tax, and makes the code more readable.</p>
<h3 id="hidden-causes">Hidden Causes</h3>
<p>Outputs, changes in state, are the most commonly cited manifestation of side effects. But another readability-harming practice is what some refer to as side causes. Consider:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + y;
}

<span class="hljs-keyword">var</span> y = <span class="hljs-number">3</span>;

foo( <span class="hljs-number">1</span> );            <span class="hljs-comment">// 4</span>
</code></pre>
<p><code>y</code> is not changed by <code>foo(..)</code>, so it&apos;s not the same kind of side effect as we saw before. But now, the calling of <code>foo(..)</code> actually depends on the presence and current state of a <code>y</code>. If later, we do:</p>
<pre><code class="lang-js">y = <span class="hljs-number">5</span>;

<span class="hljs-comment">// ..</span>

foo( <span class="hljs-number">1</span> );            <span class="hljs-comment">// 6</span>
</code></pre>
<p>Might we be surprised that the call to <code>foo(1)</code> returned different results from call to call?</p>
<p><code>foo(..)</code> has an indirection of cause that is harmful to readability. The reader cannot see, without inspecting <code>foo(..)</code>&apos;s implementation carefully, what causes are contributing to the output effect. It <em>looks</em> like the argument <code>1</code> is the only cause, but it turns out it&apos;s not.</p>
<p>To aid readability, all of the causes that will contribute to determining the effect output of <code>foo(..)</code> should be made as direct and obvious inputs to <code>foo(..)</code>. The reader of the code will clearly see the cause(s) and effect.</p>
<h4 id="fixed-state">Fixed State</h4>
<p>Does avoiding side causes mean the <code>foo(..)</code> function cannot reference any free variables?</p>
<p>Consider this code:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + bar( x );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>;
}

foo( <span class="hljs-number">3</span> );            <span class="hljs-comment">// 9</span>
</code></pre>
<p>It&apos;s clear that for both <code>foo(..)</code> and <code>bar(..)</code>, the only direct cause is the <code>x</code> parameter. But what about the <code>bar(x)</code> call? <code>bar</code> is just an identifier, and in JS it&apos;s not even a constant (non-reassignable variable) by default. The <code>foo(..)</code> function is relying on the value of <code>bar</code> -- a variable that references the second function -- as a free variable.</p>
<p>So is this program relying on a side cause?</p>
<p>I say no. Even though it is <em>possible</em> to overwrite the <code>bar</code> variable&apos;s value with some other function, I am not doing so in this code, nor is it a common practice of mine or precedent to do so. For all intents and purposes, my functions are constants (never reassigned).</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.141592</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x * PI;
}

foo( <span class="hljs-number">3</span> );            <span class="hljs-comment">// 9.424776000000001</span>
</code></pre>
<p><strong>Note:</strong> JavaScript has <code>Math.PI</code> built-in, so we&apos;re only using the <code>PI</code> example in this text as a convenient illustration. In practice, always use <code>Math.PI</code> instead of defining your own!</p>
<p>How about the above code snippet? Is <code>PI</code> a side cause of <code>foo(..)</code>?</p>
<p>Two observations will help us answer that question in a reasonable way:</p>
<ol>
<li><p>Think about every call you might ever make to <code>foo(3)</code>. Will it always return that <code>9.424..</code> value? <strong>Yes.</strong> Every single time. If you give it the same input (<code>x</code>), it will always return the same output.</p>
</li>
<li><p>Could you replace every usage of <code>PI</code> with its immediate value, and could the program run <strong>exactly</strong> the same as it did before? <strong>Yes.</strong> There&apos;s no part of this program that relies on being able to change the value of <code>PI</code> -- indeed since it&apos;s a <code>const</code>, it cannot be reassigned -- so the <code>PI</code> variable here is only for readability/maintenance sake. Its value can be inlined without any change in program behavior.</p>
</li>
</ol>
<p>My conclusion: <code>PI</code> here is not a violation of the spirit of minimizing/avoiding side effects (or causes). Nor is the <code>bar(x)</code> call in the previous snippet.</p>
<p>In both cases, <code>PI</code> and <code>bar</code> are not part of the state of the program. They&apos;re fixed, non-reassignable (&quot;constant&quot;) references. If they don&apos;t change throughout the program, we don&apos;t have to worry about tracking them as changing state. As such, they don&apos;t harm our readability. And they cannot be the source of bugs related to variables changing in unexpected ways.</p>
<p><strong>Note:</strong> The use of <code>const</code> above does not, in my opinion, make the case that <code>PI</code> is absolved as a side cause; <code>var PI</code> would lead to the same conclusion. The lack of reassigning <code>PI</code> is what matters, not the inability to do so. We&apos;ll discuss <code>const</code> in a later chapter.</p>
<h4 id="randomness">Randomness</h4>
<p>You may never have considered it before, but randomness is impure. A function that uses <code>Math.random()</code> can never be pure, because you cannot ensure/predict its output based on its input. So any code that generates unique random IDs/etc will by definition be considered reliant on your program&apos;s side causes.</p>
<p>In computing, we use what&apos;s called pseudo-random algorithms for generation. Turns out true randomness is pretty hard, so we just kinda fake it with complex algorithms that produce values that seem observably random. These algorithms calculate long streams of numbers, but the secret is, the sequence is actually predictable if you know the starting point. This starting point is referred to as a seed.</p>
<p>Some languages let you specify the seed value for the random number generation. If you always specify the same seed, you&apos;ll always get the same sequence of outputs from subsequent &quot;random number&quot; generations. This is incredibly useful for testing purposes, for example, but incredibly dangerous for real world application usage.</p>
<p>In JS, the randomness of <code>Math.random()</code> calculated is based on an indirect input, because you cannot specify the seed. As such, we have to treat built-in random number generation as an impure side cause.</p>
<h3 id="io-effects">I/O Effects</h3>
<p>It may not have been terribly obvious yet, but the most common (and essentially unavoidable) form of side cause/effect is I/O (input/output). A program with no I/O is totally pointless, because its work cannot be observed in any way. Useful programs must at a minimum have output, and many also need input. Input is a side cause and output is a side effect.</p>
<p>The typical input for the browser JS programmer is user events (mouse, keyboard) and for output is the DOM. If you work more in Node.js, you may more likely receive input from, and send output to, the file system, network connections, and/or the <code>stdin</code>/<code>stdout</code> streams.</p>
<p>As a matter of fact, these sources can be both input and output, both cause and effect. Take the DOM, for example. We update (side effect) a DOM element to show text or an image to the user, but the current state of the DOM is an implicit input (side cause) to those operations as well.</p>
<h3 id="side-bugs">Side Bugs</h3>
<p>The scenarios where side causes and side effects can lead to bugs are as varied as the programs in existence. But let&apos;s examine a scenario to illustrate these hazards, in hopes that they help us recognize similar mistakes in our own programs.</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> users = {};
<span class="hljs-keyword">var</span> userOrders = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUserData</span>(<span class="hljs-params">userId</span>) </span>{
    ajax( <span class="hljs-string">&quot;http://some.api/user/&quot;</span> + userId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onUserData</span>(<span class="hljs-params">userData</span>)</span>{
        users[userId] = userData;
    } );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchOrders</span>(<span class="hljs-params">userId</span>) </span>{
    ajax( <span class="hljs-string">&quot;http://some.api/orders/&quot;</span> + userId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onOrders</span>(<span class="hljs-params">orders</span>)</span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; orders.length; i++) {
            <span class="hljs-comment">// keep a reference to latest order for each user</span>
            users[userId].latestOrder = orders[i];
            userOrders[orders[i].orderId] = orders[i];
        }
    } );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteOrder</span>(<span class="hljs-params">orderId</span>) </span>{
    <span class="hljs-keyword">var</span> user = users[ userOrders[orderId].userId ];
    <span class="hljs-keyword">var</span> isLatestOrder = (userOrders[orderId] == user.latestOrder);

    <span class="hljs-comment">// deleting the latest order for a user?</span>
    <span class="hljs-keyword">if</span> (isLatestOrder) {
        hideLatestOrderDisplay();
    }

    ajax( <span class="hljs-string">&quot;http://some.api/delete/order/&quot;</span> + orderId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onDelete</span>(<span class="hljs-params">success</span>)</span>{
        <span class="hljs-keyword">if</span> (success) {
            <span class="hljs-comment">// deleted the latest order for a user?</span>
            <span class="hljs-keyword">if</span> (isLatestOrder) {
                user.latestOrder = <span class="hljs-literal">null</span>;
            }

            userOrders[orderId] = <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLatestOrder) {
            showLatestOrderDisplay();
        }
    } );
}
</code></pre>
<p>I bet for some of you readers one of the potential bugs here is fairly obvious. If the callback <code>onOrders(..)</code> runs before the <code>onUserData(..)</code> callback, it will attempt to add a <code>latestOrder</code> property to a value (the <code>userData</code> object at <code>users[userId]</code>) that&apos;s not yet been set.</p>
<p>So one form of &quot;bug&quot; that can occur with logic that relies on side causes/effects is the race condition of two different operations (async or not!) that we expect to run in a certain order but under some cases may run in a different order. There are strategies for ensuring the order of operations, and it&apos;s fairly obvious that order is critical in that case.</p>
<p>Another more subtle bug can bite us here. Did you spot it?</p>
<p>Consider this order of calls:</p>
<pre><code class="lang-js">fetchUserData( <span class="hljs-number">123</span> );
onUserData(..);
fetchOrders( <span class="hljs-number">123</span> );
onOrders(..);

<span class="hljs-comment">// later</span>

fetchOrders( <span class="hljs-number">123</span> );
deleteOrder( <span class="hljs-number">456</span> );
onOrders(..);
onDelete(..);
</code></pre>
<p>Do you see the interleaving of <code>fetchOrders(..)</code> / <code>onOrders(..)</code> with the <code>deleteOrder(..)</code> / <code>onDelete(..)</code> pair? That potential sequencing exposes a weird condition with our side causes/effects of state management.</p>
<p>There&apos;s a delay in time (because of the callback) between when we set the <code>isLatestOrder</code> flag and when we use it to decide if we should empty the <code>latestOrder</code> property of the user data object in <code>users</code>. During that delay, if <code>onOrders(..)</code> callback fires, it can potentially change which order value that user&apos;s <code>latestOrder</code> references. When <code>onDelete(..)</code> then fires, it will assume it still needs to unset the <code>latestOrder</code> reference.</p>
<p>The bug: the data (state) <em>might</em> now be out of sync. <code>latestOrder</code> will be unset, when potentially it should have stayed pointing at a newer order that came in to <code>onOrders(..)</code>.</p>
<p>The worst part of this kind of bug is that you don&apos;t get a program-crashing exception like we did with the other bug. We just simply have state that is incorrect; our application&apos;s behavior is &quot;silently&quot; broken.</p>
<p>The sequencing dependency between <code>fetchUserData(..)</code> and <code>fetchOrders(..)</code> is fairly obvious, and straightforwardly addressed. But it&apos;s far less clear that there&apos;s a potential sequencing dependency between <code>fetchOrders(..)</code> and <code>deleteOrder(..)</code>. These two seem to be more independent. And ensuring that their order is preserved is more tricky, because you don&apos;t know in advance (before the results from <code>fetchOrders(..)</code>) whether that sequencing really must be enforced.</p>
<p>Yes, you can recompute the <code>isLatestOrder</code> flag once <code>deleteOrder(..)</code> fires. But now you have a different problem: your UI state can be out of sync.</p>
<p>If you had called the <code>hideLatestOrderDisplay()</code> previously, you&apos;ll now need to call <code>showLatestOrderDisplay()</code>, but only if a new <code>latestOrder</code> has in fact been set. So you&apos;ll need to track at least three states: was the deleted order the &quot;latest&quot; originally, and is the &quot;latest&quot; set, and are those two orders different? These are solvable problems, of course. But they&apos;re not obvious by any means.</p>
<p>All of these hassles are because we decided to structure our code with side causes/effects on a shared set of state.</p>
<p>Functional programmers detest these sorts of side cause/effect bugs because of how much it hurts our ability read, reason about, validate, and ultimately <strong>trust</strong> the code. That&apos;s why they take the principle to avoid side causes/effects so seriously.</p>
<p>There are multiple different strategies for avoiding/fixing side causes/effects. We&apos;ll talk about some later in this chapter, and others in later chapters. I&apos;ll say one thing for certain: <strong>writing with side causes/effects is often of our normal default</strong> so avoiding them is going to require careful and intentional effort.</p>
<h2 id="once-is-enough-thanks">Once Is Enough, Thanks</h2>
<p>If you must make side effect changes to state, one class of operations that&apos;s useful for limiting the potential trouble is idempotence. If your update of a value is idempotent, then data will be resilient to the case where you might have multiple such updates from different side effect sources.</p>
<p>The definition of idempotence is a little confusing; mathematicians use a slightly different meaning than programmers typically do. However, both perspectives are useful for the functional programmer.</p>
<p>First, let&apos;s give a counter example that is neither mathematically nor programmingly idempotent:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCounter</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">if</span> (obj.count &lt; <span class="hljs-number">10</span>) {
        obj.count++;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>This function mutates an object via reference by incrementing <code>obj.count</code>, so it produces a side effect on that object. If <code>updateCounter(o)</code> is called multiple times -- while <code>o.count</code> is less than <code>10</code>, that is -- the program state changes each time. Also, the output of <code>updateCounter(..)</code> is a boolean, which is not suitable to feed back into a subsequent call of <code>updateCounter(..)</code>.</p>
<h3 id="mathematic-idempotence">Mathematic Idempotence</h3>
<p>From the mathematical point of view, idempotence means an operation whose output won&apos;t ever change after the first call, if you feed that output back into the operation over and over again. In other words, <code>foo(x)</code> would produce the same output as <code>foo(foo(x))</code>, <code>foo(foo(foo(x)))</code>, etc.</p>
<p>A typical mathematic example is <code>Math.abs(..)</code> (absolute value). <code>Math.abs(-2)</code> is <code>2</code>, which is the same result as <code>Math.abs(Math.abs(Math.abs(Math.abs(-2))))</code>. Utilities like <code>Math.min(..)</code>, <code>Math.max(..)</code>, <code>Math.round(..)</code>, <code>Math.floor(..)</code> and <code>Math.ceil(..)</code> are also idempotent.</p>
<p>Some custom mathematical operations we could define with this same characteristic:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPower0</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow( x, <span class="hljs-number">0</span> );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">snapUp3</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x - (x % <span class="hljs-number">3</span>) + (x % <span class="hljs-number">3</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">3</span>);
}

toPower0( <span class="hljs-number">3</span> ) == toPower0( toPower0( <span class="hljs-number">3</span> ) );            <span class="hljs-comment">// true</span>

snapUp3( <span class="hljs-number">3.14</span> ) == snapUp3( snapUp3( <span class="hljs-number">3.14</span> ) );        <span class="hljs-comment">// true</span>
</code></pre>
<p>Mathematical-style idempotence is <strong>not</strong> restricted to mathematic operations. Another place we can illustrate this form of idempotence is with JavaScript primitive type coercions:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">42</span>, y = <span class="hljs-string">&quot;hello&quot;</span>;

<span class="hljs-built_in">String</span>( x ) === <span class="hljs-built_in">String</span>( <span class="hljs-built_in">String</span>( x ) );                <span class="hljs-comment">// true</span>

<span class="hljs-built_in">Boolean</span>( y ) === <span class="hljs-built_in">Boolean</span>( <span class="hljs-built_in">Boolean</span>( y ) );            <span class="hljs-comment">// true</span>
</code></pre>
<p>Earlier in the text, we explored a common FP tool that fulfills this form of idempotence:</p>
<pre><code class="lang-js">identity( <span class="hljs-number">3</span> ) === identity( identity( <span class="hljs-number">3</span> ) );    <span class="hljs-comment">// true</span>
</code></pre>
<p>Certain string operations are also naturally idempotent, such as:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upper</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x.toUpperCase();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lower</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x.toLowerCase();
}

<span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;Hello World&quot;</span>;

upper( str ) == upper( upper( str ) );                <span class="hljs-comment">// true</span>

lower( str ) == lower( lower( str ) );                <span class="hljs-comment">// true</span>
</code></pre>
<p>We can even design more sophisticated string formatting operations in an idempotent way, such as:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currency</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">parseFloat</span>(
        <span class="hljs-built_in">String</span>( val ).replace( <span class="hljs-regexp">/[^\d.-]+/g</span>, <span class="hljs-string">&quot;&quot;</span> )
    );
    <span class="hljs-keyword">var</span> sign = (num &lt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;-&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${sign}</span>$<span class="hljs-subst">${Math.abs( num ).toFixed( 2 )}</span>`</span>;
}

currency( <span class="hljs-number">-3.1</span> );                                    <span class="hljs-comment">// &quot;-$3.10&quot;</span>

currency( <span class="hljs-number">-3.1</span> ) == currency( currency( <span class="hljs-number">-3.1</span> ) );    <span class="hljs-comment">// true</span>
</code></pre>
<p><code>currency(..)</code> illustrates an important technique: in some cases the developer can take extra steps to normalize an input/output operation to ensure the operation is idempotent where it normally wouldn&apos;t be.</p>
<p>Wherever possible, restricting side effects to idempotent operations is much better than unrestricted updates.</p>
<h3 id="programming-idempotence">Programming Idempotence</h3>
<p>The programming-oriented definition for idempotence is similar, but less formal. Instead of requiring <code>f(x) === f(f(x))</code>, this view of idempotence is just that <code>f(x);</code> results in the same program behavior as <code>f(x); f(x);</code>. In other words, the result of calling <code>f(x)</code> subsequent times after the first call doesn&apos;t change anything.</p>
<p>That perspective fits more with our observations about side effects, because it&apos;s more likely that such an <code>f(..)</code> operation creates an idempotent side effect rather than necessarily returning an idempotent output value.</p>
<p>This idempotence-style is often cited for HTTP operations (verbs) such as GET or PUT. If an HTTP REST API is properly following the specification guidance for idempotence, PUT is defined as an update operation that fully replaces a resource. As such, a client could either send a PUT request once or multiple times (with the same data), and the server would have the same resultant state regardless.</p>
<p>Thinking about this in more concrete terms with programming, let&apos;s examine some side effect operations for their idempotence (or not):</p>
<pre><code class="lang-js"><span class="hljs-comment">// idempotent:</span>
obj.count = <span class="hljs-number">2</span>;
a[a.length - <span class="hljs-number">1</span>] = <span class="hljs-number">42</span>;
person.name = upper( person.name );

<span class="hljs-comment">// non-idempotent:</span>
obj.count++;
a[a.length] = <span class="hljs-number">42</span>;
person.lastUpdated = <span class="hljs-built_in">Date</span>.now();
</code></pre>
<p>Remember: the notion of idempotence here is that each idempotent operation (like <code>obj.count = 2</code>) could be repeated multiple times and not change the program operation beyond the first update. The non-idempotent operations change the state each time.</p>
<p>What about DOM updates?</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> hist = <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&quot;orderHistory&quot;</span> );

<span class="hljs-comment">// idempotent:</span>
hist.innerHTML = order.historyText;

<span class="hljs-comment">// non-idempotent:</span>
<span class="hljs-keyword">var</span> update = <span class="hljs-built_in">document</span>.createTextNode( order.latestUpdate );
hist.appendChild( update );
</code></pre>
<p>The key difference illustrated here is that the idempotent update replaces the DOM element&apos;s content. The current state of the DOM element is irrelevant, because it&apos;s unconditionally overwritten. The non-idempotent operation adds content to the element; implicitly, the current state of the DOM element is part of computing the next state.</p>
<p>It won&apos;t always be possible to define your operations on data in an idempotent way, but if you can, it will definitely help reduce the chances that your side effects will crop up to break your expectations when you least expect it.</p>
<h2 id="pure-bliss">Pure Bliss</h2>
<p>A function with no side causes/effects is called a pure function. A pure function is idempotent in the programming sense, since it cannot have any side effects. Consider:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x,y</span>) </span>{
    <span class="hljs-keyword">return</span> x + y;
}
</code></pre>
<p>All the inputs (<code>x</code> and <code>y</code>) and outputs (<code>return ..</code>) are direct; there are no free variable references. Calling <code>add(3,4)</code> multiple times would be indistinguishable from only calling it once. <code>add(..)</code> is pure and programming-style idempotent.</p>
<p>However, not all pure functions are idempotent in the mathematical sense, because they don&apos;t have to return a value that would be suitable for feeding back in as their own input. Consider:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateAverage</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
        sum += list[i];
    }
    <span class="hljs-keyword">return</span> sum / list.length;
}

calculateAverage( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>] );            <span class="hljs-comment">// 9</span>
</code></pre>
<p>The output <code>9</code> is not an array, so you cannot pass it back in: <code>calculateAverage(calculateAverage( .. ))</code>.</p>
<p>As we discussed earlier, a pure function <em>can</em> reference free variables, as long as those free variables aren&apos;t side causes.</p>
<p>Some examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.141592</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">circleArea</span>(<span class="hljs-params">radius</span>) </span>{
    <span class="hljs-keyword">return</span> PI * radius * radius;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cylinderVolume</span>(<span class="hljs-params">radius,height</span>) </span>{
    <span class="hljs-keyword">return</span> height * circleArea( radius );
}
</code></pre>
<p><code>circleArea(..)</code> references the free variable <code>PI</code>, but it&apos;s a constant so it&apos;s not a side cause. <code>cylinderVolume(..)</code> references the free variable <code>circleArea</code>, which is also not a side cause because this program treats it as, in effect, a constant reference to its function value. Both these functions are pure.</p>
<p>Another example where a function can still be pure but reference free variables is with closure:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unary</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onlyOneArg</span>(<span class="hljs-params">arg</span>)</span>{
        <span class="hljs-keyword">return</span> fn( arg );
    };
}
</code></pre>
<p><code>unary(..)</code> itself is clearly pure -- its only input is <code>fn</code> and its only output is the <code>return</code>ed function -- but what about the inner function <code>onlyOneArg(..)</code>, which closes over the free variable <code>fn</code>?</p>
<p>It&apos;s still pure because <code>fn</code> never changes. In fact, we have full confidence in that fact because lexically speaking, those few lines are the only ones that could possibly reassign <code>fn</code>.</p>
<p><strong>Note:</strong> <code>fn</code> is a reference to a function object, which is by default a mutable value. Somewhere else in the program <em>could</em> for example add a property to this function object, which technically &quot;changes&quot; the value (mutation, not reassignment). However, since we&apos;re not relying on anything about <code>fn</code> other than our ability to call it, and it&apos;s not possible to affect the callability of a function value, <code>fn</code> is still effectively unchanging for our reasoning purposes; it cannot be a side cause.</p>
<p>Another common way to articulate a function&apos;s purity is: <strong>given the same input(s), it always produces the same output.</strong> If you pass <code>3</code> to <code>circleArea(..)</code>, it will always output the same result (<code>28.274328</code>).</p>
<p>If a function <em>can</em> produce a different output each time it&apos;s given the same inputs, it is impure. Even if such a function always <code>return</code>s the same value, if it produces an indirect output side effect, the program state is changed each time it&apos;s called; this is impure.</p>
<p>Impure functions are undesirable because they make all of their calls harder to reason about. A pure function&apos;s call is perfectly predictable. When someone reading the code sees multiple <code>circleArea(3)</code> calls, they won&apos;t have to spend any extra effort to figure out what its output will be <em>each time</em>.</p>
<h3 id="purely-relative">Purely Relative</h3>
<p>We have to be very careful when talking about a function being pure. JavaScript&apos;s dynamic value nature makes it all too easy to have non-obvious side causes/effects.</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rememberNumbers</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caller</span>(<span class="hljs-params">fn</span>)</span>{
        <span class="hljs-keyword">return</span> fn( nums );
    };
}

<span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];

<span class="hljs-keyword">var</span> simpleList = rememberNumbers( list );
</code></pre>
<p><code>simpleList(..)</code> looks like a pure function, as it&apos;s a reference to the inner function <code>caller(..)</code>, which just closes over the free variable <code>nums</code>. However, there&apos;s multiple ways that <code>simpleList(..)</code> can actually turn out to be impure.</p>
<p>First, our assertion of purity is based on the array value (referenced both by <code>list</code> and <code>nums</code>) never changing:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">median</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> (nums[<span class="hljs-number">0</span>] + nums[nums.length - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;
}

simpleList( median );        <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// ..</span>

list.push( <span class="hljs-number">6</span> );

<span class="hljs-comment">// ..</span>

simpleList( median );        <span class="hljs-comment">// 3.5</span>
</code></pre>
<p>When we mutate the array, the <code>simpleList(..)</code> call changes its output. So, is <code>simpleList(..)</code> pure or impure? Depends on your perspective. It&apos;s pure for a given set of assumptions. It could be pure in any program that didn&apos;t have the <code>list.push(6)</code> mutation.</p>
<p>We could guard against this kind of impurity by altering the definition of <code>rememberNumbers(..)</code>. One approach is to duplicate the <code>nums</code> array:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rememberNumbers</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-comment">// make a copy of the array</span>
    nums = nums.slice();

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caller</span>(<span class="hljs-params">fn</span>)</span>{
        <span class="hljs-keyword">return</span> fn( nums );
    };
}
</code></pre>
<p>But an even trickier hidden side effect could be lurking:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];

<span class="hljs-comment">// make `list[0]` be a getter with a side effect</span>
<span class="hljs-built_in">Object</span>.defineProperty(
    list,
    <span class="hljs-number">0</span>,
    {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;[0] was accessed!&quot;</span> );
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
    }
);

<span class="hljs-keyword">var</span> simpleList = rememberNumbers( list );
<span class="hljs-comment">// [0] was accessed!</span>
</code></pre>
<p>A perhaps more robust option is to change the signature of <code>rememberNumbers(..)</code> to not receive an array in the first place, but rather the numbers as individual arguments:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rememberNumbers</span>(<span class="hljs-params">...nums</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caller</span>(<span class="hljs-params">fn</span>)</span>{
        <span class="hljs-keyword">return</span> fn( nums );
    };
}

<span class="hljs-keyword">var</span> simpleList = rememberNumbers( ...list );
<span class="hljs-comment">// [0] was accessed!</span>
</code></pre>
<p>The two <code>...</code>s have the effect of copying <code>list</code> into <code>nums</code> instead of passing it by reference.</p>
<p><strong>Note:</strong> The console message side effect here comes not from <code>rememberNumbers(..)</code> but from the <code>...list</code> spreading. So in this case, both <code>rememberNumbers(..)</code> and <code>simpleList(..)</code> are pure.</p>
<p>But what if the mutation is even harder to spot? Composition of a pure function with an impure function <strong>always</strong> produces an impure function. If we pass an impure function into the otherwise pure <code>simpleList(..)</code>, it&apos;s now impure:</p>
<pre><code class="lang-js"><span class="hljs-comment">// yes, a silly contrived example :)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstValue</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastValue</span>(<span class="hljs-params">nums</span>) </span>{
    <span class="hljs-keyword">return</span> firstValue( nums.reverse() );
}

simpleList( lastValue );    <span class="hljs-comment">// 5</span>

list;                        <span class="hljs-comment">// [1,2,3,4,5] -- OK!</span>

simpleList( lastValue );    <span class="hljs-comment">// 1</span>
</code></pre>
<p><strong>Note:</strong> Despite <code>reverse()</code> looking safe (like other array methods in JS) in that it returns a reversed array, it actually mutates the array rather than creating a new one.</p>
<p>We need a more robust definition of <code>rememberNumbers(..)</code> to guard against the <code>fn(..)</code> mutating its closed over <code>nums</code> via reference:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rememberNumbers</span>(<span class="hljs-params">...nums</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">caller</span>(<span class="hljs-params">fn</span>)</span>{
        <span class="hljs-comment">// send in a copy!</span>
        <span class="hljs-keyword">return</span> fn( nums.slice() );
    };
}
</code></pre>
<p>So is <code>simpleList(..)</code> reliably pure yet!? <strong>Nope.</strong> :(</p>
<p>We&apos;re only guarding against side effects we can control (mutating by reference). Any function we pass that has other side effects will have polluted the purity of <code>simpleList(..)</code>:</p>
<pre><code class="lang-js">simpleList( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">impureIO</span>(<span class="hljs-params">nums</span>)</span>{
    <span class="hljs-built_in">console</span>.log( nums.length );
} );
</code></pre>
<p>In fact, there&apos;s no way to define <code>rememberNumbers(..)</code> to make a perfectly-pure <code>simpleList(..)</code> function.</p>
<p>Purity is about confidence. But we have to admit that in many cases, <strong>any confidence we feel is actually relative to the context</strong> of our program and what we know about it. In practice (in JavaScript) the question of function purity is not about being absolutely pure or not, but about a range of confidence in its purity.</p>
<p>The more pure, the better. The more effort you put into making a function pure(r), the higher your confidence will be when you read code that uses it, and that will make that part of the code more readable.</p>
<h2 id="there-or-not">There Or Not</h2>
<p>So far, we&apos;ve defined function purity both as a function without side causes/effects and as a function that, given the same input(s), always produces the same output. These are just two different ways of looking at the same characteristics.</p>
<p>But a third way of looking at function purity, and perhaps the most widely accepted definition, is that a pure function has referential transparency.</p>
<p>Referential transparency is the assertion that a function call could be replaced by its output value, and the overall program behavior wouldn&apos;t change. In other words, it would be impossible to tell from the program&apos;s execution whether the function call was made or its return value was inlined in place of the function call.</p>
<p>From the perspective of referential transparency, both of these programs have identical behavior as they are built with pure functions:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateAverage</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
        sum += list[i];
    }
    <span class="hljs-keyword">return</span> sum / list.length;
}

<span class="hljs-keyword">var</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>];

<span class="hljs-keyword">var</span> avg = calculateAverage( nums );

<span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;The average is:&quot;</span>, avg );        <span class="hljs-comment">// The average is: 9</span>
</code></pre>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateAverage</span>(<span class="hljs-params">list</span>) </span>{
    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
        sum += list[i];
    }
    <span class="hljs-keyword">return</span> sum / list.length;
}

<span class="hljs-keyword">var</span> nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>];

<span class="hljs-keyword">var</span> avg = <span class="hljs-number">9</span>;

<span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;The average is:&quot;</span>, avg );        <span class="hljs-comment">// The average is: 9</span>
</code></pre>
<p>The only difference between these two snippets is that in the latter one, we skipped the <code>calculateAverage(nums)</code> call and just inlined its ouput (<code>9</code>). Since the rest of the program behaves identically, <code>calculateAverage(..)</code> has referential transparency, and is thus a pure function.</p>
<h3 id="mentally-transparent">Mentally Transparent</h3>
<p>The notion that a referentially transparent pure function <em>can be</em> replaced with its output does not mean that it <em>should literally be</em> replaced. Far from it.</p>
<p>The reasons we build functions into our programs instead of using pre-computed magic constants are not just about responding to changing data, but also about readability with proper abstractions, etc. The function call to calculate the average of that list of numbers makes that part of the program more readable than the line that just assigns the value explicitly. It tells the story to the reader of where <code>avg</code> comes from, what it means, etc.</p>
<p>What we&apos;re really suggesting with referential transparency is that as you&apos;re reading a program, once you&apos;ve mentally computed what a pure function call&apos;s output is, you no longer need to think about what that exact function call is doing when you see it in code, especially if it appears multiple times.</p>
<p>That result becomes kinda like a mental <code>const</code> declaration, which as you&apos;re reading you can transparently swap in and not spend any more mental energy working out.</p>
<p>Hopefully the importance of this characteristic of a pure function is obvious. We&apos;re trying to make our programs more readable. One way we can do that is give the reader less work, by providing assistance to skip over the unnecessary stuff so they can focus on the important stuff.</p>
<p>The reader shouldn&apos;t need to keep re-computing some outcome that isn&apos;t going to change (and doesn&apos;t need to). If you define a pure function with referential transparency, the reader won&apos;t have to.</p>
<h3 id="not-so-transparent">Not So Transparent?</h3>
<p>What about a function that has a side effect, but this side effect isn&apos;t ever observed or relied upon anywhere else in the program? Does that function still have referential transparency?</p>
<p>Here&apos;s one:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateAverage</span>(<span class="hljs-params">list</span>) </span>{
    sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
        sum += list[i];
    }
    <span class="hljs-keyword">return</span> sum / list.length;
}

<span class="hljs-keyword">var</span> sum, nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>];

<span class="hljs-keyword">var</span> avg = calculateAverage( nums );
</code></pre>
<p>Did you spot it?</p>
<p><code>sum</code> is an outer free variable that <code>calculateAverage(..)</code> uses to do its work. But, every time we call <code>calculateAverage(..)</code> with the same list, we&apos;re going to get <code>9</code> as the output. And this program couldn&apos;t be distinguished in terms of behavior from a program that replaced the <code>calculateAverage(nums)</code> call with the value <code>9</code>. No other part of the program cares about the <code>sum</code> variable, so it&apos;s an unobserved side effect.</p>
<p>Is a side cause/effect that&apos;s unobserved like this tree?</p>
<blockquote>
<p>If a tree falls in the forest, but no one is around to hear it, does it still make a sound?</p>
</blockquote>
<p>By the narrowest definition of referential transparency, I think you&apos;d have to say <code>calculateAverage(..)</code> is still a pure function. But as we&apos;re trying to not just be academic in our study, but balanced with pragmatism, I think this conclusion needs more perspective. Let&apos;s explore.</p>
<h4 id="performance-effects">Performance Effects</h4>
<p>Often times, you&apos;ll find these kind of side-effects-that-go-unobserved being used to optimize the performance of an operation. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> cache = [];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">specialNumber</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-comment">// if we&apos;ve already calculated this special number,</span>
    <span class="hljs-comment">// skip the work and just return it from the cache</span>
    <span class="hljs-keyword">if</span> (cache[n] !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">return</span> cache[n];
    }

    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        x += i % <span class="hljs-number">2</span>;
        y += i % <span class="hljs-number">3</span>;
    }

    cache[n] = (x * y) / (n + <span class="hljs-number">1</span>);

    <span class="hljs-keyword">return</span> cache[n];
}

specialNumber( <span class="hljs-number">6</span> );                <span class="hljs-comment">// 4</span>
specialNumber( <span class="hljs-number">42</span> );            <span class="hljs-comment">// 22</span>
specialNumber( <span class="hljs-number">1E6</span> );            <span class="hljs-comment">// 500001</span>
specialNumber( <span class="hljs-number">987654321</span> );        <span class="hljs-comment">// 493827162</span>
</code></pre>
<p>This silly <code>specialNumber(..)</code> algorithm is deterministic and thus pure from the definition that it always gives the same output for the same input. It&apos;s also pure from the referential transparency perspective -- replace any call to <code>specialNumber(42)</code> with <code>22</code> and the end result of the program is the same.</p>
<p>However, the function has to do quite a bit of work to calculate some of the bigger numbers, especially the <code>987654321</code> input. If we needed to get that particular special number multiple times throughout our program, the <code>cache</code>ing of the result means that subsequent calls are far more efficient.</p>
<p><strong>Note:</strong> An interesting thing to ponder: is the heat produced by the CPU while performing any given operation an unavoidable side effect of even the most pure functions/programs? What about just the CPU time delay as it spends time on a pure operation before it can do another one?</p>
<p>Don&apos;t be so quick to assume that you could just run the <code>specialNumber(987654321)</code> calculation once and manually stick that result in some variable / constant. Programs are often highly modularized and globally accessible scopes are not usually the way you want to go around sharing state between those independent pieces. Having <code>specialNumber(..)</code> do its own caching (even though it happens to be using a global variable to do so!) is a more preferable abstraction of that state sharing.</p>
<p>The point is that if <code>specialNumber(..)</code> is the only part of the program that accesses and updates the <code>cache</code> side cause/effect, the referential transparency perspective observably holds true, and this might be seen as an acceptable pragmatic &quot;cheat&quot; of the pure function ideal.</p>
<p>But should it?</p>
<p>Typically, this sort of performance optimization side effecting is done by hiding the caching of results so they <em>cannot</em> be observed by any other part of the program. This process is referred to as memoization. I always think of that word as &quot;memorization&quot;; I have no idea if that&apos;s even remotely where it comes from, but it certainly helps me understand the concept better.</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> specialNumber = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoization</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> cache = [];

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">specialNumber</span>(<span class="hljs-params">n</span>)</span>{
        <span class="hljs-comment">// if we&apos;ve already calculated this special number,</span>
        <span class="hljs-comment">// skip the work and just return it from the cache</span>
        <span class="hljs-keyword">if</span> (cache[n] !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">return</span> cache[n];
        }

        <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
            x += i % <span class="hljs-number">2</span>;
            y += i % <span class="hljs-number">3</span>;
        }

        cache[n] = (x * y) / (n + <span class="hljs-number">1</span>);

        <span class="hljs-keyword">return</span> cache[n];
    };
})();
</code></pre>
<p>We&apos;ve contained the <code>cache</code> side causes/effects of <code>specialNumber(..)</code> inside the scope of the <code>memoization()</code> IIFE, so now we&apos;re sure that no other parts of the program <em>can</em> observe them, not just that they <em>don&apos;t</em> observe them.</p>
<p>That last sentence may seem like a subtle point, but actually I think it might be <strong>the most important point of the entire chapter</strong>. Read it again.</p>
<p>Back to this philosophical musing:</p>
<blockquote>
<p>If a tree falls in the forest, but no one is around to hear it, does it still make a sound?</p>
</blockquote>
<p>Going with the metaphor, what I&apos;m getting at is: whether the sound is made or not, it would be better if we never create a scenario where the tree can fall without us being around; we&apos;ll always hear the sound when a tree falls.</p>
<p>The purpose of reducing side causes/effects is not per se to have a program where they aren&apos;t observed, but to design a program where fewer of them are possible, because this makes the code easier to reason about. A program with side causes/effects that <em>happen</em> to not be observed is not nearly as effective in this goal as a program that <em>cannot</em> observe them.</p>
<p>If side causes/effect can happen, the writer and reader must mentally juggle them. Make it so they can&apos;t happen, and both writer and reader will find more confidence over what can and cannot happen in any part.</p>
<h2 id="purifying">Purifying</h2>
<p>What can you do if you have an impure function that you cannot refactor to be pure?</p>
<p>You need to figure what kind of side causes/effects the function has. It may be that the side causes/effects come variously from lexical free variables, mutations-by-reference, or even <code>this</code> binding. We&apos;ll look at approaches that address each of these scenarios.</p>
<h3 id="containing-effects">Containing Effects</h3>
<p>If the nature of the concerned side causes/effects is with lexical free variables, and you have the option to modify the surrounding code, you can encapsulate them using scope.</p>
<p>Recall:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> users = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUserData</span>(<span class="hljs-params">userId</span>) </span>{
    ajax( <span class="hljs-string">&quot;http://some.api/user/&quot;</span> + userId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onUserData</span>(<span class="hljs-params">userData</span>)</span>{
        users[userId] = userData;
    } );
}
</code></pre>
<p>One option for purifying this code is to create a wrapper around both the variable and the impure function. Essentially, the wrapper has to receive as input &quot;the entire universe&quot; of state it can operate on.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safer_fetchUserData</span>(<span class="hljs-params">userId,users</span>) </span>{
    <span class="hljs-comment">// simple, naive ES6+ shallow object copy, could also</span>
    <span class="hljs-comment">// be done w/ various libs or frameworks</span>
    users = <span class="hljs-built_in">Object</span>.assign( {}, users );

    fetchUserData( userId );

    <span class="hljs-comment">// return the copied state</span>
    <span class="hljs-keyword">return</span> users;


    <span class="hljs-comment">// ***********************</span>

    <span class="hljs-comment">// original untouched impure function:</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUserData</span>(<span class="hljs-params">userId</span>) </span>{
        ajax( <span class="hljs-string">&quot;http://some.api/user/&quot;</span> + userId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onUserData</span>(<span class="hljs-params">userData</span>)</span>{
            users[userId] = userData;
        } );
    }
}
</code></pre>
<p>Both <code>userId</code> and <code>users</code> are input for the original <code>fetchUserData</code>, and <code>users</code> is also output. The <code>safer_fetchUserData(..)</code> takes both of these inputs, and returns <code>users</code>. To make sure we&apos;re not creating a side effect on the outside when <code>users</code> is mutated, we make a local copy of <code>users</code>.</p>
<p>This technique has limited usefulness mostly because if you cannot modify a function itself to be pure, you&apos;re not that likely to be able to modify its surrounding code either. However, it&apos;s helpful to explore it if possible, as it&apos;s the simplest of our fixes.</p>
<p>Regardless of whether this will be a practical technique for refactoring to pure functions, the more important take-away is that function purity only need be skin deep. That is, the <strong>purity of a function is judged from the outside</strong>, regardless of what goes on inside. As long as a function&apos;s usage behaves pure, it is pure. Inside a pure function, impure techniques can be used -- in moderation! -- for a variety of reasons, including most commonly, for performance. It&apos;s not necessarily, as they say, &quot;turtles all the way down&quot;.</p>
<p>Be very careful, though. Any part of the program that&apos;s impure, even if it&apos;s wrapped with and only ever used via a pure function, is a potential source of bugs and confusion for readers of the code. The overall goal is to reduce side effects wherever possible, not just hide them.</p>
<h3 id="covering-up-effects">Covering Up Effects</h3>
<p>Many times you will be unable to modify the code to encapsulate the lexical free variables inside the scope of a wrapper function. For example, the impure function may be in a third-party library file that you do not control, containing something like:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> nums = [];
<span class="hljs-keyword">var</span> smallCount = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> largeCount = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateMoreRandoms</span>(<span class="hljs-params">count</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
        <span class="hljs-keyword">let</span> num = <span class="hljs-built_in">Math</span>.random();

        <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">0.5</span>) {
            largeCount++;
        }
        <span class="hljs-keyword">else</span> {
            smallCount++;
        }

        nums.push( num );
    }
}
</code></pre>
<p>The brute-force strategy to <em>quarantine</em> the side causes/effects when using this utility in the rest of our program is to create an interface function that performs the following steps:</p>
<ol>
<li>capture the to-be-affected current states</li>
<li>set initial input states</li>
<li>run the impure function</li>
<li>capture the side effect states</li>
<li>restore the original states</li>
<li>return the captured side effect states</li>
</ol>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safer_generateMoreRandoms</span>(<span class="hljs-params">count,initial</span>) </span>{
    <span class="hljs-comment">// (1) save original state</span>
    <span class="hljs-keyword">var</span> orig = {
        nums,
        smallCount,
        largeCount
    };

    <span class="hljs-comment">// (2) setup initial pre-side effects state</span>
    nums = initial.nums.slice();
    smallCount = initial.smallCount;
    largeCount = initial.largeCount;

    <span class="hljs-comment">// (3) beware impurity!</span>
    generateMoreRandoms( count );

    <span class="hljs-comment">// (4) capture side effect state</span>
    <span class="hljs-keyword">var</span> sides = {
        nums,
        smallCount,
        largeCount
    };

    <span class="hljs-comment">// (5) restore original state</span>
    nums = orig.nums;
    smallCount = orig.smallCount;
    largeCount = orig.largeCount;

    <span class="hljs-comment">// (6) expose side effect state directly as output</span>
    <span class="hljs-keyword">return</span> sides;
}
</code></pre>
<p>And to use <code>safer_generateMoreRandoms(..)</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> initialStates = {
    nums: [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>],
    smallCount: <span class="hljs-number">2</span>,
    largeCount: <span class="hljs-number">1</span>
};

safer_generateMoreRandoms( <span class="hljs-number">5</span>, initialStates );
<span class="hljs-comment">// { nums: [0.3,0.4,0.5,0.8510024448959794,0.04206799238...</span>

nums;            <span class="hljs-comment">// []</span>
smallCount;        <span class="hljs-comment">// 0</span>
largeCount;        <span class="hljs-comment">// 0</span>
</code></pre>
<p>That&apos;s a lot of manual work to avoid a few side causes/effects; it&apos;d be a lot easier if we just didn&apos;t have them in the first place. But if we have no choice, this extra effort is well worth it to avoid surprises in our programs.</p>
<p><strong>Note:</strong> This technique really only works when you&apos;re dealing with synchronous code. Asynchronous code can&apos;t reliably be managed with this approach because it can&apos;t prevent surprises if other parts of the program access/modify the state variables in the interim.</p>
<h3 id="evading-effects">Evading Effects</h3>
<p>When the nature of the side effect to be dealt with is a mutation of a direct input value (object, array, etc) via reference, we can again create an interface function to interact with instead of the original impure function.</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleInactiveUsers</span>(<span class="hljs-params">userList,dateCutoff</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; userList.length; i++) {
        <span class="hljs-keyword">if</span> (userList[i].lastLogin == <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// remove the user from the list</span>
            userList.splice( i, <span class="hljs-number">1</span> );
            i--;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userList[i].lastLogin &lt; dateCutoff) {
            userList[i].inactive = <span class="hljs-literal">true</span>;
        }
    }
}
</code></pre>
<p>Both the <code>userList</code> array itself, plus the objects in it, are mutated. One strategy to protect against these side effects is to do a deep (well, just not shallow) copy first:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safer_handleInactiveUsers</span>(<span class="hljs-params">userList,dateCutoff</span>) </span>{
    <span class="hljs-comment">// make a copy of both the list and its user objects</span>
    <span class="hljs-keyword">let</span> copiedUserList = userList.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapper</span>(<span class="hljs-params">user</span>)</span>{
        <span class="hljs-comment">// copy a `user` object</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign( {}, user );
    } );

    <span class="hljs-comment">// call the original function with the copy</span>
    handleInactiveUsers( copiedUserList, dateCutoff );

    <span class="hljs-comment">// expose the mutated list as a direct output</span>
    <span class="hljs-keyword">return</span> copiedUserList;
}
</code></pre>
<p>The success of this technique will be dependent on the thoroughness of the <em>copy</em> you make of the value. Using <code>userList.slice()</code> would not work here, since that only creates a shallow copy of the <code>userList</code> array itself. Each element of the array is an object that needs to be copied, so we need to take extra care. Of course, if those objects have objects inside them (they might!), the copying needs to be even more robust.</p>
<h4 id="this-revisited"><code>this</code> Revisited</h4>
<p>Another variation of the via-reference side cause/effect is with <code>this</code>-aware functions having <code>this</code> as an implicit input. See &quot;What&apos;s This&quot; in Chapter 2 for more info on why the <code>this</code> keyword is problematic for FPers.</p>
<p>Consider:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> ids = {
    prefix: <span class="hljs-string">&quot;_&quot;</span>,
    generate() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.prefix + <span class="hljs-built_in">Math</span>.random();
    }
};
</code></pre>
<p>Our strategy is similar to the previous section&apos;s discussion: create an interface function that forces the <code>generate()</code> function to use a predictable <code>this</code> context:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safer_generate</span>(<span class="hljs-params">context</span>) </span>{
    <span class="hljs-keyword">return</span> ids.generate.call( context );
}

<span class="hljs-comment">// *********************</span>

safer_generate( { prefix: <span class="hljs-string">&quot;foo&quot;</span> } );
<span class="hljs-comment">// &quot;foo0.8988802158307285&quot;</span>
</code></pre>
<p>These strategies are in no way fool-proof; the safest protection against side causes/effects is to not do them. But if you&apos;re trying to improve the readability and confidence level of your program, reducing the side causes/effects wherever possible is a huge step forward.</p>
<p>Essentially, we&apos;re not really eliminating side causes/effects, but rather containing and limiting them, so that more of our code is verifiable and reliable. If we later run into program bugs, we know that the parts of our code still using side causes/effects are the most likely culprits.</p>
<h2 id="summary">Summary</h2>
<p>Side effects are harmful to code readability and quality because they make your code much harder to understand. Side effects are also one of the most common <em>causes</em> of bugs in programs, because juggling them is hard. Idempotence is a strategy for restricting side effects by essentially creating one-time-only operations.</p>
<p>Pure functions are how we best avoid side effects. A pure function is one that always returns the same output given the same input, and has no side causes or side effects. Referential transparency further states that -- more as a mental exercise than a literal action -- a pure function&apos;s call could be replaced with its output and the program would not have altered behavior.</p>
<p>Refactoring an impure function to be pure is the preferred option. But if that&apos;s not possible, try encapsulating the side causes/effects, or creating a pure interface against them.</p>
<p>No program can be entirely free of side effects. But prefer pure functions in as many places as that&apos;s practical. Collect impure functions side effects together as much as possible, so that it&apos;s easier to identify and audit the most likely culprits of bugs when they arise.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch4.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 4: Composing Functions">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch6.html" class="navigation navigation-next " aria-label="Next page: Chapter 6: Value Immutability">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 5: Reducing Side Effects","level":"1.8","depth":1,"next":{"title":"Chapter 6: Value Immutability","level":"1.9","depth":1,"path":"ch6.md","ref":"ch6.md","articles":[]},"previous":{"title":"Chapter 4: Composing Functions","level":"1.7","depth":1,"path":"ch4.md","ref":"ch4.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"ch5.md","mtime":"2017-03-13T18:38:58.762Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-03-13T19:03:34.902Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

